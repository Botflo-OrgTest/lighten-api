#!/usr/bin/env perl 

# 
#
# a quick test harness 
#	given recusrive.jsc , 
#	run  tests of names recursive.t.[pf].\d+(.json)
#	the p should pass the f should fail
#
#	recursive.jsc should be a valid json object as tested by python -mjson.tool 

# work this up into a more riggerous system FIX

use strict;
use JSON;
use Data::Dumper;

my $JSONSCHEMACMD  = "jsonschema-2.7-";
$JSONSCHEMACMD  = "jsonschema";

my $buf; 
$buf = `which $JSONSCHEMACMD`; 
if (not defined $buf or $?){
    die("Something is probably wrong with a lack of ($JSONSCHEMACMD),  try installing it 'pip install jsonschema' : quiting\n");
}

my ($testfile) = $ARGV[0]; 
if (not defined $testfile){
	die("give me a testfile...\n");
}

if (not -f $testfile){
	die(" testfile ($testfile) needs ot be a file\n");
}

if ($testfile =~ /'/ ){
	die(" seriously? \"'\" in the filename, that is just rude...\n");
}

my $testfiletxt; 
{
	local $/ =1;
	$testfiletxt = `cat '$testfile'`; 
}

my $testfiletouse = $testfile; 

if (defined $testfiletxt and $testfiletxt =~ /URLPWD/){
	my $cwd = `pwd`;
	chomp($cwd);
	$testfiletxt =~ s/URLPWD/file:\/\/$cwd/;
	$testfiletouse = "$testfile.tmp";
	my $out;
	open $out , ">$testfiletouse" || die "Unable to open ($testfiletouse) ($!)\n"; 
	print $out  $testfiletxt;
	close $out;	
}

my $failures = 0; 

my ($uret,$ret); 

sub check_json_of_file{
			my ($fn) = @_; 
		$ret = `python -mjson.tool '$fn'`; 

		$uret = $?; 

		if ($uret){
			$failures ++; 
		# perl -e "use JSON; decode_json(join '',<>) " < orgs.t.p.86.json 
			# diffent diagnostics.
	#		print `perl -e "use JSON; decode_json(join "\\n" ,<>) " < '$fn' `; 
			my $buf;	
			$buf = `cat '$fn'`;
			print("The file ($fn) is not seemingly in json format ($ret)\n");
			decode_json($buf);
			die("ugh");
		}else{
		#	print "($fn) passed json validation\n";	
		}
}

check_json_of_file($testfiletouse);
if ( -f "basic_components.jsc"){
	check_json_of_file("basic_components.jsc");
}



my (@testfiles);
my ($dirname); 	
my ($basefilename);
my ($suffix)='';

if ($testfile =~ /\A(.*\/)?([^\/]+)\.jsc(.json)?\Z/){
	($dirname) = $1; 	
	($basefilename) = $2;

	if (defined $3 and length $3){
		$suffix = $3;
	}	
	
	if (not defined $dirname or 0 == length($dirname) ){ 
		$dirname = ".";	
	}

	#print "dirname ($dirname) basefilename ($basefilename)\n"; 
	opendir(my $dh , 	$dirname ) || die "failed to open ($dirname) ($!)\n";
	@testfiles = sort { -M $a <=> -M $b } grep { /\A\Q$basefilename\E\.t\.[p|f]\.(\d+)(\.json)?\Z/ } readdir ($dh); 
	close $dh; 
	#print  "Testfiles : " .Dumper(\@testfiles);
}else{
	die( "strange filename, not sure what to do...($testfile)\n");
}

map { 
	my ($t) = $_; 
	my $tfn = "$dirname/$t"; 
	if ($t =~ /\.([p|f])\.\d+(\.json)?\Z/){
		my $pf = $1; 

		check_json_of_file($tfn);

                #my ($cmd) = "jsonschema-2.7 -i '$tfn' '$testfiletouse'  2>&1 ";
		my ($cmd) = "$JSONSCHEMACMD -i '$tfn' '$testfiletouse'  2>&1 ";
		$ret = `$cmd`;
		$uret = $?;

		if ($pf eq 'p'){ 
			if ($uret){ 
				print "expected pass of ($t) failed\n($ret) cmd($cmd)\n\n"; 
				$failures++;
			}else{
				print "pass of ($t)\n"; 
			}
		}else{
			if ($uret){ 
				print "pass of ($t)\n"; 
			}else{
				print "expected failure of ($t) failed\n"; 
				$failures++;
			}
		}
	}else{
		die("invalid test name ($t)\n");
	}
	
} @testfiles;

print "\n\nfailures ($failures)\n";

if ($failures){
	print "FAILURE\n";		
	exit(2);
}else{
	print "pass\n\n";
	exit(0);
}





